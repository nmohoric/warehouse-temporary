{"templates": {"pre": {"body": "~each var=$results~\n```~each var=$item.body as=l~\n~$l~\n~end~```\n~end~\n"}, "resource_list": {"body": "~each var=$results as=r~\n~attachment color=$r.Color~\n**~$r.Kind~ Name:** ~$r.Name~\n**Namespace:** ~$r.Namespace~\n~if cond=$r.Kind == Pod ~\n**Pod Ready:** ~$r.ReadyCount~/~$r.Count~\n**Pod Status:** ~$r.Status~\n**Pod Restarts:** ~$r.Restarts~\n**Pod Node:** ~$r.Node~\n~end~\n~if cond=$r.Kind == Service ~\n**Service ClusterIP:** ~$r.ClusterIP~\n**Service Type:** ~$r.Type~\n**Service ExternalIP:** ~$r.ExternalIP~\n~end~\n~if cond=$r.Kind == Deployment ~\n**Deployment Desired:** ~$r.Desired~\n~if cond=$r.Current not_empty?~**Deployment Current:** ~$r.Current~~end~\n~if cond=$r.Available not_empty?~**Deployment Available:** ~$r.Available~~end~\n~if cond=$r.Unavailable not_empty?~**Deployment Unavailable:** ~$r.Unavailable~~end~\n~if cond=$r.Updated not_empty?~**Deployment Updated:** ~$r.Updated~~end~\n~end~\n**~$r.Kind~ Timestamp:** ~$r.Timestamp~\n~end~\n~end~\n"}}, "commands": {"scale": {"executable": "/usr/local/bin/cog-command", "options": {"replicas": {"required": true, "type": "int", "description": "The new desired number of replicas. Required."}, "current-replicas": {"required": false, "type": "int", "description": "Precondition for current size. Requires that the current size of the resource match this value in order to scale."}}, "description": "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job.", "rules": ["must have kubectl:write"], "long_description": "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job.\nScale also allows users to specify one or more preconditions for the scale action.\n\nIf --current-replicas or --resource-version is specified, it is validated before the scale is attempted, and it is guaranteed that the precondition holds true when the scale is sent to the server.\n\nkubectl scale --current-replicas=2 --replicas=3 deployment/mysql\n", "arguments": "RESOUCE_TYPE/RESOURCE_NAME"}, "run": {"rules": ["must have kubectl:write"], "executable": "/usr/local/bin/cog-command", "long_description": "Creates a deployment or job to manage the created container(s).\n\nkubectl:run nginx --image=nginx:1.11-alpine --port=80\n", "options": {"image": {"required": true, "type": "string", "description": "The image for the container to run."}, "expose": {"required": false, "type": "bool", "description": "If true, a public, external service is created for the container(s) which are run"}, "port": {"required": false, "type": "int", "description": "The port that this container exposes.  If --expose is true, this is also the port used by the service that is created."}}, "description": "Create and run a particular image, possibly replicated."}, "logs": {"executable": "/usr/local/bin/cog-command", "options": {"tail": {"required": false, "type": "int", "description": "Lines of recent log file to display. Defaults to 20 with no selector, showing all log lines otherwise 10, if a selector is provided."}, "container": {"short_flag": "c", "required": false, "type": "string", "description": "Print the logs of this container"}, "previous": {"short_flag": "p", "required": false, "type": "bool", "description": "If true, print the logs for the previous instance of the container in a pod if it exists. (default print current.)"}, "timestamps": {"required": false, "type": "bool", "description": "Include timestamps on each line in the log output"}, "since": {"required": false, "type": "string", "description": "Only return logs newer than a relative duration like 5s, 2m, or 3h. Defaults to all logs."}, "selector": {"short_flag": "l", "required": false, "type": "list", "description": "Selector (label query) to filter on"}}, "description": "Print the logs for a container in a pod or specified resource.", "rules": ["must have kubectl:read"], "long_description": "Print the logs for a container in a pod or specified resource. If the pod has only one container, the container name is optional.\n\nkubectl logs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER] [options]\n", "arguments": "[POD]"}, "get": {"rules": ["must have kubectl:read"], "executable": "/usr/local/bin/cog-command", "long_description": "Valid resource types include:\n\n  * clusters (valid only for federation apiservers)\n  * componentstatuses (aka 'cs')\n  * configmaps (aka 'cm')\n  * daemonsets (aka 'ds')\n  * deployments (aka 'deploy')\n  * endpoints (aka 'ep')\n  * events (aka 'ev')\n  * horizontalpodautoscalers (aka 'hpa')\n  * ingresses (aka 'ing')\n  * jobs\n  * limitranges (aka 'limits')\n  * namespaces (aka 'ns')\n  * networkpolicies\n  * nodes (aka 'no')\n  * persistentvolumeclaims (aka 'pvc')\n  * persistentvolumes (aka 'pv')\n  * pods (aka 'po')\n  * podsecuritypolicies (aka 'psp')\n  * podtemplates\n  * replicasets (aka 'rs')\n  * replicationcontrollers (aka 'rc')\n  * resourcequotas (aka 'quota')\n  * secrets\n  * serviceaccounts (aka 'sa')\n  * services (aka 'svc')\n  * statefulsets\n  * storageclasses\n  * thirdpartyresources\n\nThis command will hide resources that have completed. For instance, pods that are in the Succeeded or Failed phases. You can see the full results for any resource by providing the '--show-all' flag.\n\nkubectl:get pods\n", "options": {"selector": {"short_flag": "l", "required": false, "type": "list", "description": "Selector (label query) to filter on"}, "all-namespaces": {"required": false, "type": "bool", "description": "If present, list the requested object(s) across all namespaces."}, "sort-by": {"required": false, "type": "string", "description": "If non-empty, sort list types using this field specification.  The field specification is expressed as a JSONPath expression"}, "show-all": {"short_flag": "a", "required": false, "type": "bool", "description": "When printing, show all resources (default hide terminated pods.)"}}, "description": "Display one or many resources."}, "expose": {"executable": "/usr/local/bin/cog-command", "options": {"type": {"required": false, "type": "string", "description": "Type for this service (ClusterIP, NodePort, or LoadBalancer). Default is 'ClusterIP'."}, "port": {"required": false, "type": "int", "description": "The port that the service should serve on. Copied from the resource being exposed, if unspecified"}, "target-port": {"required": false, "type": "int", "description": "Name or number for the port on the container that the service should direct traffic to. Optional."}}, "description": "Expose a resource as a new Kubernetes service.", "rules": ["must have kubectl:write"], "long_description": "Looks up a deployment, service, replica set, replication controller or pod by name and uses the selector for that resource as the selector for a new service on the specified port. A deployment or replica set will be exposed as a service only if its selector is convertible to a selector that service supports, i.e. when the selector contains only the matchLabels component. Note that if no port is specified via --port and the exposed resource has multiple ports, all will be re-used by the new service. Also if no labels are specified, the new service will re-use the labels from the resource it exposes.\n\nPossible resources include (case insensitive):\n\npod (po), service (svc), replicationcontroller (rc), deployment (deploy), replicaset (rs)\n\nkubectl expose deployment nginx --port=80 --container-port=8000\n", "arguments": "RESOUCE_TYPE RESOURCE_NAME"}, "describe": {"executable": "/usr/local/bin/cog-sub-command", "options": {"selector": {"short_flag": "l", "required": false, "type": "list", "description": "Selector (label query) to filter on"}}, "description": "Show details of a specific resource or group of resources.", "rules": ["must have kubectl:read"], "long_description": "This command joins many API calls together to form a detailed description of a given resource or group of resources.\n\n  $ kubectl describe TYPE NAME_PREFIX\n\nwill first check for an exact match on TYPE and NAME PREFIX. If no such resource exists, it will output details for every resource that has a name prefixed with NAME PREFIX.\n", "arguments": "RESOURCE_TYPE/RESOURCE_NAME CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N"}, "set-image": {"rules": ["must have kubectl:write"], "executable": "/usr/local/bin/cog-sub-command", "long_description": "Update existing container image(s) of resources.\n\nPossible resources include (case insensitive):\n  pod (po), replicationcontroller (rc), deployment (deploy), daemonset (ds), job, replicaset (rs)\n", "arguments": "RESOURCE_TYPE/RESOURCE_NAME CONTAINER_NAME_1=CONTAINER_IMAGE_1 ... CONTAINER_NAME_N=CONTAINER_IMAGE_N", "description": "Update image of a pod template."}, "delete": {"executable": "/usr/local/bin/cog-command", "options": {"force": {"required": false, "type": "bool", "description": "Immediate deletion of some resources may result in inconsistency or data loss and requires confirmation."}, "grace-period": {"required": false, "type": "int", "description": "Period of time in seconds given to the resource to terminate gracefully. Ignored if negative."}, "selector": {"short_flag": "l", "required": false, "type": "list", "description": "Selector (label query) to filter on"}}, "description": "Delete resources by filenames, stdin, resources and names, or by resources and label selector.", "rules": ["must have kubectl:admin"], "long_description": "Resources and label selector are accepted.\n\nSome resources, such as pods, support graceful deletion. These resources define a default period before they are forcibly terminated (the grace period) but you may override that value with the --grace-period flag, or pass --now to set a grace-period of 1. Because these resources often represent entities in the cluster, deletion may not be acknowledged immediately. If the node hosting a pod is down or cannot reach the API server, termination may take significantly longer than the grace period. To force delete a resource,  you must pass a grace   period of 0 and specify the --force flag.\n\nIMPORTANT: Force deleting pods does not wait for confirmation that the pod's processes have been terminated, which can leave those processes running until the node detects the deletion and completes graceful deletion. If your processes use shared storage or talk to a remote API and depend on the name of the pod to identify themselves, force deleting those pods may result in multiple processes running on different machines using the same identification which may lead to data corruption or inconsistency. Only force delete pods when you are sure the pod is terminated, or if your application can tolerate multiple copies of the same pod running at once. Also, if you force delete pods the scheduler may place new pods on those nodes before the node has released those resources and causing those pods to be evicted immediately.\n\nNote that the delete command does NOT do resource version checks, so if someone submits an update to a resource right when you submit a delete, their update will be lost along with the rest of the resource.\n\n**Note:** Confirmation over Slack not supported\n", "arguments": "[RESOUCE_TYPE RESOURCE_NAME]"}}, "description": "Interact with Kubernetes", "name": "kubectl", "version": "0.1.15", "docker": {"image": "quay.io/honestbee/cog-kubectl", "tag": "0.1.15"}, "cog_bundle_version": 4, "config": {"notes": "When creating the service account for use with the following environment variables, make sure the RBAC role used has permissions as required.\n", "env": [{"var": "KUBERNETES_TOKEN", "description": "Requried service account token for Kubernetes API access"}, {"var": "KUBERNETES_SERVER", "description": "Required Kubernetes API endpoint"}, {"var": "KUBERNETES_CERT", "description": "Required Kubernetes API certificate for secure execution"}]}, "long_description": "This bundle provides commands for exposing kubectl commands through Chat. Permissions are used to control which users are authorized to run each command. Listing and searching for resources requires the kubectl:read permission. Modifying the state or other values of a resource requires the kubectl:write permission. And, destroying a resource requires the kubectl:admin permission.\n", "permissions": ["kubectl:read", "kubectl:write", "kubectl:admin"]}